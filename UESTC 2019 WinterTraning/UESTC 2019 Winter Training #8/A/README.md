### Description

给你一个长度为N的序列A，和q个操作，对于每个操作有以下两种情况：

1 p x —— 将A[p]修改为x

2 a b —— 统计Elf（i，j）的sum，其中a <= i <= j <=b 且 Elf（i，j）表示Ai到Aj的异或和。（即统计a到b所有子区间的异或和的sum）并模4001后输出。

数据范围：

1 <= n,m <= 1e5

1 <= Ai <= 1000

### Sample

##### Input

```
4
8
1 2 3 4
2 1 2
1 1 2
2 1 3
2 1 4
1 3 7
2 1 3
1 4 5
2 1 4
```

##### Output

```
6
11
34
23
32
```

### Solution

先将每个数二进制分解，然后按位考虑。对于统计子区间，就是统计每一位的[a,b]区间内有多少个子区间的异或和位1，然后按位计算贡献。因此对于每一位，可以将拆位后的01数组先做一个异或前缀和，假设前缀和后的序列为b，那么查询有多少个子区间的异或和为1，就是查询[a-1,b]间有多少个pair(l,r)其中`a-1 <= l <= r <=b`满足b[r]^b[l-1]==1，也就是两个端点值一个为1，一个为0，因此可以转化为查询区间中有多少个1和多少0，答案就是两个的个数相乘（每个1去找一个0），按位计算贡献后相加即可。对于修改操作，由于是对前缀和后的序列b建树，因此修改一个单点就是把[x,n]的值都修改，如果修改后的某一位与修改前不同，则就是对这一位上的[x,n]区间异或1。查询和修改可以用线段树来完成，注意建树是对前缀和序列建树，范围是[0,n]。

ps.经常将统计子区间类的问题先做前缀和然后转化为求区间内pair数。

