### Description

给你一个a ~ z的全排列p，表示第i个字母（1<=i<=26，即a ~ z）变化一次会变成p[i] 。

如abcdefghijklmnpqrstuvwxyzo表示a可以变化到a，b会变化到b....y会变化到z，z会变化到o。

问你一个长度为n的随机串最早变化回本身的期望X是多少。输出X*26^N % 1e9+7

数据范围：

多组数据，T <= 10

1 <= N <= 1e9

给出的全排列均为小写字母

### Sample

##### Input

```
2
2
abcdefghijklmnpqrstuvwxyzo
1
abcdefghijklmnopqrstuvwxyz
```

##### Output

```
5956
26
```

### Solution

长度为N的串有26^N种，因此输出的答案即是每种情况下第一次变回本身的次数之和。

首先flyod求出每种字母变回本身的最少次数。

考虑对于串s，他变回本身的次数即是lcm（dis[s[1]],dis[s[2]],...,dis[s[n]]），即每个字母变回自己的lcm，发现只需要统计出现过哪些字母即可，相同字母到本身的最少次数是一样的，因此只要统计串中26种字母出现过哪些字母，出现过字母的lcm即是对于一个串s的答案。

因此有一种复杂为2^26的做法，枚举每种字母出现与否，确定了出现过哪几种字母后，每一个这样的串的贡献就是所有出现过字母的lcm。现在还要计算有多少个这样的串，相当于长度为n的串出现过x种字母，每种字母至少1个。我们定义num[x]表示长度为n的串种出现了x种不同的字母的方案数，那么`num[x]=x^n-C(x,1)*num[1]-C(x,2)*num[2]-...-C(x,x-1)*num[x-1]`，x^n表示n个字母，每个字母有x种选择，再容斥减去只出现1种、只出现2种..只出现x-1种字母的情况，就是长度为n的只出现x种字母的方案数，因此答案就是对于2^26种情况，算出每种情况的x和lcm，答案就是segma lcm*num[x]。

但是会T，进一步观察可以发现每个字母其实都处一个环中，一个长度为L的环中包含了L个字母，并且他们变回自身的步数都是L，并且在lcm中我们可以只关心出现了哪几种数字，也就是只出现了哪几种dis。因为一共只有26个字母，所以最多只会有6种不同的dis出现（1+2+3+4+5+6+7=28>26）。我们可以转而先统计不同dis的字母各有几个，然后枚举每种dis的字母出现了几个。

cnt[i]表示dis为i的字母个数，假设枚举每种dis出现的字母个数分别为x1,x2,...xtot（tot为不同的dis种类数），那么x=x1+x2+..xtot，对答案的贡献为`C(cnt[1],x1)*C(cnt[2],x2)*..*C(cnt[tot],xtot)*lcm(xi非0所对应的dis)*num[x]`也就是从cnt[1]个dis为L1的选x1，从cnt[2]个dis为L2的选x2个，一共x个字母，符合要求的串有`C(cnt[1],x1)*C(cnt[2],x2)*..*C(cnt[tot],xtot)**num[x]`种，他们第一次变回本身的次数均为`lcm(xi大于0所对应的Li)`。预处理num[]数组，最后枚举的复杂度极低。
