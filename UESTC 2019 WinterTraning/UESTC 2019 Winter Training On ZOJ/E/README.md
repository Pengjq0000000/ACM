### Description

给你两个数M和K，求一个最小的N，使得K在1~N按字典序排序后rank恰好为M。若不存在这样的N输出0。

数据范围：

1 <= K <= 1e8

1 <= M <= 1e8

### Sample

##### Input

```
2
2 4
10000001 100000000
```

##### Output

```
11
1000000088888880
```

### Solution

先判断若N==K，此时K的rank是多少。

比如K是2345，那么在1~2345这些数中，排在2345前面的有：

1000~2344

100~234

​    10~23

​      1~2

这些数，统计出这些数有多少个后，我们就可以计算出2345现在的rank是多少。

那么我们还需要在2345前面添加M'=M-rank个数，才能使得K的排名是M，容易得知和2345位数相同且比它大的数字典序一定在它之后，因此新增的数一定是长度比2345的长度大的，他们应该分别是：

长度为5：10000~2344 9

长度为6：1000000~2344 99

长度为7：10000000~2344 999

...

这些数，利用前缀和算出M‘落在哪个区间中，再进一步算出N的值。

对于判错有两种，一种是给的M过大，比如对于1，10，100...这类数来说，他们的排名只能是1，2，3...不会往后移动；另一种是给的M过小，即当N==K时，rank就已经大于了M。这两种情况应该输出0，其他情况按照上面所述计算即可。
